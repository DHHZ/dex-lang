' ## Gradients on manifolds
An example of how to generalize the Dex `linearize` and `grad` functions to take
derivatives and gradients of functions on manifolds.

' ### Tangent space
The difference between differentiating on $\mathbb{R}^n$ and on general
manifolds is that in the general case, the manifold tangent space type may be
different to the manifold representation type. The tangent space at a single
point will always be isomorphic to $\mathbb{R}^n$ for some $n$, but here we
allow any vector space type `b` for flexibility.

' The proper definition of a tangent space is quite abstract, so no further details will be provided here. Wikipedia has quite a good
[article](https://en.wikipedia.org/wiki/Tangent_space) for more information.

' Practically, the two components required for defining the differentiable
structure on the manifold are the exponential map (a mapping from the tangent
space at p to the manifold, such that zero is mapped to $p$, and straight lines
are mapped to geodesics), and its inverse. Note that "exponential map" is a
somewhat overloaded term, here we are talking about it in a Riemannian geometry
sense.

' In the `TangentSpace` interface, `manifold` is the type which can represent points
on the manifold. `tangent` is the type which can represent points in a tangent space
to the manifold.  Ideally `tangent` would be an associated type of `manifold` so that the
compiler is able to infer the tangent space type from the manifold type, but
this feature is not yet available in Dex.

interface [VSpace tangent] TangentSpace manifold tangent
  -- Given a point p on the manifold M and a point v in its tangent space TpM,
  -- this returns another point q on the manifold.
  -- Must satisfy tangentExponentialMap p zero == p
  -- (tangentExponentialMap p) will be linearized around zero, so it is
  -- important that any operations used have well-defined derivatives for inputs
  -- p, zero.
  tangentExponentialMap: manifold -> tangent -> manifold
  -- (tangentLogarithmMap p) is the pointwise inverse to
  -- (tangentExponentialMap p).
  -- Must satisfy tangentLogarithmMap p p == zero
  -- (tangentLogarithmMap p) will be linearized around p, so it is important
  -- that any operations used have well-defined derivatives for inputs p, p.
  tangentLogarithmMap: manifold -> manifold -> tangent


'### Differentiation functions

'We can then define a version of the Dex `linearize` function which works on
manifolds.  To see intuitively why this works, consider the following diagram.
We would like to obtain a linearized version of the function "across the top" of
the diagram, and we can form this by linearizing the function formed from the
bottom three sides of the square.

:html
   "<img
     src=\"https://user-images.githubusercontent.com/33986545/122416078-5a23ef00-cf80-11eb-83d5-d0d5986e8d20.png\"
     width=\"100%\">"
> <html output>

def manifoldLinearize [TangentSpace manifoldA tangentA,
                       TangentSpace manifoldB tangentB, Add tangentA]
    (f: manifoldA -> manifoldB) (x: manifoldA) :
    (manifoldB & tangentA --o tangentB) = 
  y = f x
  tangentSpaceMapping : tangentA -> tangentB =
    \ v . tangentLogarithmMap y $ f $ tangentExponentialMap x v
  rawLinearize = linearize tangentSpaceMapping zero
  (y, snd rawLinearize)

' A full proof that this is in fact a correct formulation is a bit more
involved, so we leave it out here. The general idea is to use the differentiable
curves formulation of the tangent space, and to treat the tangent space at a 
point $x$ as both the tangent space, and as a local chart.

' Before we can define `grad` for manifolds, we need to create the trivial
instance of a TangentSpace for vector spaces. In this case, we view the tangent
space at $x$ to be just a copy of the vector space, centred on $x$.

instance [VSpace a] TangentSpace a a
  tangentExponentialMap = \ p v . p + v
  tangentLogarithmMap = \ p q . q - p

' Now we can define a version of the Dex `grad` function which works on
manifolds.

def manifoldGrad [TangentSpace manifoldA tangentA, VSpace tangentA]
  (f: manifoldA -> Float) (x: manifoldA) : tangentA = 
  linearized: (Float & (tangentA --o Float)) = manifoldLinearize f x
  transposeLinear (snd linearized) 1.0


' ### Equivalence to standard differentiation
As a sense check we make sure that these functions give the same output as the
non-manifold versions on functions which are defined on $\mathbb{R}^n$.

x = for i:(Fin 10). IToF (ordinal i) / 10.

def myFunc (x : (n => Float)) : Float =
  sum $ for i. if (mod (ordinal i) 2 == 0) then (exp x.i) else (sin x.i)

original = linearize myFunc x
-- Need to explicitly set up the types here, due to missing associated types.
new : (Float & ((Fin 10 => Float) --o Float)) = manifoldLinearize myFunc x

fst original ~~ fst new
> True

snd original x ~~ snd new x
> True


' ### Quaternions Example
For a more complex use-case, we consider the SO3 manifold of 3D rotations, with
the usual 4D quaternion representation. Again, the full definition of
quaternions has a few subtleties, but a simple intuition is that a rotation by
an angle $\theta$ about a unit-length axis $(u, v, w)$ is represented by the
quaternion $ cos(\theta / 2) + \bold{i}\ u\ sin(\theta / 2) + \bold{j}\ v\ sin(\theta / 2) + \bold{k}\ w\ sin(\theta / 2)$.
The components of a quaternion are often labelled $w$ for the real component,
$x$ for the $\bold{i}$ component, $y$ for the $\bold{j}$ component and $z$ for
the $\bold{k}$ component.

' Generally we use unit quaternions, i.e. those where
$x^2 + y^2 + z^2 + w^2 = 1$, but any non-zero quaternion can also be considered
as a valid rotation, by defining scalar multiples of the same quaternion to
represent the same rotation.

' We re-use the data structures and some of the functions from the
`quaternions.dx` example.

data Quaternion = Q {x:Float & y:Float & z:Float & w:Float}

-- Conversion functions from a quaternion to an array of four components.
def quatAsVec (Q{x, y, z, w}: Quaternion) : (Fin 4 => Float) = [x, y, z, w]
def quatFromVec ([x, y, z, w]: Fin 4 => Float) : Quaternion = Q{x, y, z, w}

-- General normalization functions for arrays.
def squareMagnitude (x:a=>Float) : Float = sum $ for i. x.i * x.i 
def magnitude (x:a=>Float) : Float = sqrt $ squareMagnitude x
def normalize (x:a=>Float) : a=> Float = (1.0 / (magnitude x)) .* x

-- Normalization for quaternions.
def quatNormalize (q: Quaternion) : Quaternion =
  quatFromVec $ normalize $ quatAsVec q

-- The identity quaternion, representing a no-op rotation.
quatIdent = Q{x=0.0, y=0.0, z=0.0, w=1.0}

instance Add Quaternion
  add = \ x y. quatFromVec $ (quatAsVec x) + quatAsVec y
  sub = \ x y. quatFromVec $ (quatAsVec x) - quatAsVec y
  zero = quatFromVec $ zero

' Scaling a quaternion does not affect the rotation it represents, but is still
useful for numerical computations.

instance VSpace Quaternion
  scaleVec = \ s x. quatFromVec (s .* quatAsVec x)

instance HasAllClose Quaternion
  allclose = \atol rtol a b.
    allclose (quatAsVec atol) (quatAsVec rtol) (quatAsVec a) (quatAsVec b)

instance HasDefaultTolerance Quaternion
  atol = quatFromVec atol
  rtol = quatFromVec rtol

' Quaternion multiplication is composition of rotations. This formula can be
derived from the relations that $ij = k$, $ji = -k$, $jk = i$, $kj = -i$,
$ki = j$, $ik = -j$, $i^2 = j^2 = k^2 = -1$. These can also be used to derive
the given expression for the quaternion inverse.

instance Mul Quaternion
  mul = \ (Q{x,y,z,w}) (Q{x=x',y=y',z=z',w=w'}). Q {
        x = w*x' + x*w' + y*z' - z*y',
        y = w*y' - x*z' + y*w' + z*x',
        z = w*z' + x*y' - y*x' + z*w',
        w = w*w' - x*x' - y*y' - z*z'
  }
  one = quatIdent

def quatConj ((Q {x, y, z, w}):Quaternion) : Quaternion =
  Q {x=-x, y=-y, z=-z, w=w}

def quatInv (q:Quaternion) : Quaternion =
  m = magnitude $ quatAsVec q
  1.0 / (m * m) .* quatConj q

instance Monoid Quaternion
  mempty = one
  mcombine = \a b. a * b


'### Quaternions manifold structure

' We now define the exponential and logarithm map for the quaternions. The
exponential map at the identity is the well-known mapping from axis-angle to
quaternions.  Away from the identity, we can use the fact that SO3 is a Lie
group to transport the exponential map at the identity to the appropriate
tangent space, by using simple right-multiplication by $q$ to associate the
two tangent spaces.

' Since we need to ensure that the exponential function is differentiable at
zero (and similar for the logarithm), we can't use standard formulations of
functions such as `sinc x = (sin x) / x` or
`magnitude x = sqrt $ sum (for i. x.i * x.i)`. To get around this, we use some
simple Taylor series expansions, noting that this will cause reduced precision,
and running autodiff on the resulting linearizations may be inefficient.
Taking higher-order deriviatives will also lose further precision as the number
of approximation terms will be reduced by each successive differentiation.

-- Convenience alias for an array of three floats.
R3 = (Fin 3 => Float)

-- Taylor expansion for sinc (sqrt x).
def sincSqrt (x : Float) : Float = 
 (1.
  - (x  / 6.)
  + (x * x / 120.)
  - (x * x * x / 5040.)
  + (x * x * x * x / 362880.)
  - (x * x * x * x * x/ 39916800.)
  + (x * x * x * x * x *  x / 6227020800.))

-- Taylor expansion for cos (sqrt x).
def cosSqrt (x: Float) : Float = 
  (1. 
   - (x / 2.)
   + (x * x / 24.)
   - (x * x * x / 720.)
   + (x * x * x * x / 40320.) 
   - (x * x * x * x * x / 3628800.)
   + (x * x * x * x * x * x / 479001600.))

-- Taylor expansion for sinc (arccos x)
def sincAcos (x: Float) : Float = 
  (2. / pi
   + x * 4. / (pow pi 2.)
   + x * x * (8. - pow pi 2.) / (pow pi 3.)
   - x * x * x * 4. * (pow pi 2. - 12.) / (3. * pow pi 4.)
   + x * x * x * x * (384. - 16. * pow pi 2. - 3. * pow pi 4.) / (12. * pow pi 5.)
   - x * x * x * x * x * 8. * (pow pi 4. - 120.) / (15. * pow pi 6.))

-- Exponential function at the identity.
def quatExpAtIdent (v : R3) : Quaternion = 
  [x', y', z'] = v
  m2 = squareMagnitude v
  -- This is equal to sinc (m / 2) = 2 * sin (m / 2) / m
  sincHalfM = sincSqrt $ m2 / 4.
  Q {x = x' * sincHalfM / 2.,
     y = y' * sincHalfM / 2.,
     z = z' * sincHalfM / 2.,
     w = cosSqrt $ m2 / 4. }

-- Inverse to exponential function at the identity.
def quatExpAtIdentInv (q: Quaternion) : R3 =
  -- Fine to use qNormalize here, since q should be approximately unit magnitude
  -- (or at least non-zero), so the sqrt operation can be differentiated.
  (Q{x, y, z, w}) = quatNormalize q
  2. .* [x, y, z] / (sincAcos w)


instance TangentSpace Quaternion R3
  tangentExponentialMap =
    \ q v . quatExpAtIdent v * q
  tangentLogarithmMap =
    \ q p . quatExpAtIdentInv (p * quatInv q)


' Run some simple checks to make sure that the exponential and logarithm maps
have the correct properties. Use a looser tolerance for numerical innaccuracies.

looseTolerance = 0.005
quatLooseTolerance = quatFromVec $ for i. looseTolerance
tangentLooseTolerance : R3 = for i. looseTolerance

-- Just arbitrary quaternions.
quatForTestOne = quatNormalize (Q{w=1.0, x=0.5, y=-0.2, z=0.4})
quatForTestTwo = quatNormalize (Q{w=-0.4, x=0.5, y=0.8, z=-0.9})

allclose quatLooseTolerance rtol (quatExpAtIdent $ quatExpAtIdentInv quatForTestOne) (quatForTestOne)
> True

-- Same, but taking the logarithm and exponential at a non-identity point.
logOfQuatForTestOne : R3 = tangentLogarithmMap quatForTestTwo quatForTestOne
allclose quatLooseTolerance rtol (tangentExponentialMap quatForTestTwo logOfQuatForTestOne) quatForTestOne
> True

-- Should be equal to quatIdent
allclose quatLooseTolerance rtol (quatExpAtIdent $ quatExpAtIdentInv quatIdent) quatIdent
> True

-- Now the other way around
tangentVectorForTest = [0.1, -0.2, 0.3]

allclose tangentLooseTolerance rtol (quatExpAtIdentInv $ quatExpAtIdent tangentVectorForTest) tangentVectorForTest
> True

expOfTangentVectorForTest : Quaternion = tangentExponentialMap quatForTestOne tangentVectorForTest
roundTripTangentVectorForTest : R3 =
  tangentLogarithmMap quatForTestOne expOfTangentVectorForTest
allclose tangentLooseTolerance rtol roundTripTangentVectorForTest tangentVectorForTest 
> True


' To check the exponential map is doing what we think, take some arbitrary
initial rotation, and consider applying a small perturbation by some axis angle.
We can do this in two ways, which should give the same result:

'1: Applying the exponential map directly:

initialRotation = quatNormalize $ quatFromVec [0.2, 0.4, -0.35, 0.7]
perturbation = [0.01, -0.07, 0.04]

perturbedRotationDirect = tangentExponentialMap initialRotation perturbation

'2: Composing the initial rotatation with the quaternion associated to the
axis-angle perturbation, i.e. the result of applying the exponential map at the
identity to the perturbation. Note the ordering of the multiplication, which
comes from our choice of right-multiplication to associate the tangent spaces.

perturbedRotationComposed =
  (tangentExponentialMap quatIdent perturbation) * initialRotation

allclose quatLooseTolerance rtol perturbedRotationDirect perturbedRotationComposed
> True


' Now we can test the linearization and gradient functions.

-- A function to get the Euler-angle roll from a quaternion.
def quatRoll (Q{x, y, z, w} : Quaternion) : Float = 
  sinrCosp = 2. * (w * x + y * z)
  cosrCosp = 1. - 2. * (x * x + y * y)
  atan2 sinrCosp cosrCosp

-- A fixed quaternion with roll = 0.5.
quatSomeRoll = Q{x=0.247, y=0., z=0., w=0.969}
quatRoll quatSomeRoll
> 0.49916

-- A function to compose a given quaternion with fixed rotation.
def quatAddSomeRoll (q: Quaternion) : Quaternion = q * quatSomeRoll

' According to our right-multiplication definition of the tangent space mappings,
the linearized version of `quatAddSomeRoll` should just be the identity map
between tangent spaces.

linearInput = [0.05, 0.1, 0.15]
quatAddSomeRollLinearized: R3 --o R3 =
  snd $ manifoldLinearize quatAddSomeRoll quatForTestOne
allclose tangentLooseTolerance rtol (quatAddSomeRollLinearized linearInput) linearInput
> True


' Try taking the gradient of the `quatRoll` function, at various points.

-- Without associated types we have to define this, otherwise we get ambiguous
-- type variables.
def quatGrad (f: Quaternion -> Float) (x: Quaternion) : R3 = manifoldGrad f x

-- Applying the gradient at a quaternion representing a "pure roll" rotation, we
-- see that the only way to modify the roll is by adding further rotation in the
-- roll direction.
quatGrad quatRoll quatSomeRoll
> [0.999973, 0., 0.]


-- However, at other points, we can also modify the roll of the rotation by
-- moving in pitch and/or yaw directions. This demonstrates that the Euler
-- angles are not independent.
quatGrad quatRoll quatForTestOne
> [1.041025, 0.594871, 0.]

quatGrad quatRoll quatForTestTwo
> [-0.570283, 0.83349, -0.]
